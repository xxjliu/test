###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM810/Apr/2015  11:29:26 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\STMPath\26X9010(MPP 2IN1)\lib\src\stm8s_tim5.c        #
#    Command line =  "D:\STMPath\26X9010(MPP 2IN1)\lib\src\stm8s_tim5.c" -e   #
#                    -Ohz --debug --code_model small --data_model medium -o   #
#                    "D:\STMPath\26X9010(MPP 2IN1)\Debug\Obj\" --dlib_config  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Evaluation\stm8\LIB\dlstm8smn.h" -lcN                    #
#                    "D:\STMPath\26X9010(MPP 2IN1)\Debug\List\" -I            #
#                    "D:\STMPath\26X9010(MPP 2IN1)/user/\" -I                 #
#                    "D:\STMPath\26X9010(MPP 2IN1)/user/src/\" -I             #
#                    "D:\STMPath\26X9010(MPP 2IN1)/user/inc/\" -I             #
#                    "D:\STMPath\26X9010(MPP 2IN1)/addon/\" -I                #
#                    "D:\STMPath\26X9010(MPP 2IN1)/addon/src/\" -I            #
#                    "D:\STMPath\26X9010(MPP 2IN1)/addon/inc/\" -I            #
#                    "D:\STMPath\26X9010(MPP 2IN1)/sys/\" -I                  #
#                    "D:\STMPath\26X9010(MPP 2IN1)/sys/inc/\" -I              #
#                    "D:\STMPath\26X9010(MPP 2IN1)/sys/src/\" -I              #
#                    "D:\STMPath\26X9010(MPP 2IN1)/lib/\" -I                  #
#                    "D:\STMPath\26X9010(MPP 2IN1)/lib/src/\" -I              #
#                    "D:\STMPath\26X9010(MPP 2IN1)/lib/inc/\" --vregs 16      #
#    List file    =  D:\STMPath\26X9010(MPP 2IN1)\Debug\List\stm8s_tim5.lst   #
#    Object file  =  D:\STMPath\26X9010(MPP 2IN1)\Debug\Obj\stm8s_tim5.o      #
#                                                                             #
#                                                                             #
###############################################################################

D:\STMPath\26X9010(MPP 2IN1)\lib\src\stm8s_tim5.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_tim5.c
      4            * @author  MCD Application Team
      5            * @version V2.0.0
      6            * @date    25-February-2011
      7            * @brief   This file contains all the functions for the TIM5 peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_tim5.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          static void TI1_Config(uint8_t TIM5_ICPolarity, uint8_t TIM5_ICSelection, uint8_t TIM5_ICFilter);
     34          static void TI2_Config(uint8_t TIM5_ICPolarity, uint8_t TIM5_ICSelection, uint8_t TIM5_ICFilter);
     35          static void TI3_Config(uint8_t TIM5_ICPolarity, uint8_t TIM5_ICSelection, uint8_t TIM5_ICFilter);
     36          /**
     37            * @addtogroup TIM5_Public_Functions
     38            * @{
     39            */
     40          
     41          /**
     42            * @brief  Deinitializes the TIM5 peripheral registers to their default reset values.
     43            * @param  None
     44            * @retval None
     45            */
     46          void TIM5_DeInit(void)
     47          {
     48          
     49              TIM5->CR1 = (uint8_t)TIM5_CR1_RESET_VALUE;
     50              TIM5->CR2 = TIM5_CR2_RESET_VALUE;
     51              TIM5->SMCR = TIM5_SMCR_RESET_VALUE;
     52              TIM5->IER = (uint8_t)TIM5_IER_RESET_VALUE;
     53              TIM5->SR2 = (uint8_t)TIM5_SR2_RESET_VALUE;
     54          
     55              /* Disable channels */
     56              TIM5->CCER1 = (uint8_t)TIM5_CCER1_RESET_VALUE;
     57              TIM5->CCER2 = (uint8_t)TIM5_CCER2_RESET_VALUE;
     58          
     59          
     60              /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
     61              TIM5->CCER1 = (uint8_t)TIM5_CCER1_RESET_VALUE;
     62              TIM5->CCER2 = (uint8_t)TIM5_CCER2_RESET_VALUE;
     63              TIM5->CCMR1 = (uint8_t)TIM5_CCMR1_RESET_VALUE;
     64              TIM5->CCMR2 = (uint8_t)TIM5_CCMR2_RESET_VALUE;
     65              TIM5->CCMR3 = (uint8_t)TIM5_CCMR3_RESET_VALUE;
     66              TIM5->CNTRH = (uint8_t)TIM5_CNTRH_RESET_VALUE;
     67              TIM5->CNTRL = (uint8_t)TIM5_CNTRL_RESET_VALUE;
     68              TIM5->PSCR	= (uint8_t)TIM5_PSCR_RESET_VALUE;
     69              TIM5->ARRH 	= (uint8_t)TIM5_ARRH_RESET_VALUE;
     70              TIM5->ARRL 	= (uint8_t)TIM5_ARRL_RESET_VALUE;
     71              TIM5->CCR1H = (uint8_t)TIM5_CCR1H_RESET_VALUE;
     72              TIM5->CCR1L = (uint8_t)TIM5_CCR1L_RESET_VALUE;
     73              TIM5->CCR2H = (uint8_t)TIM5_CCR2H_RESET_VALUE;
     74              TIM5->CCR2L = (uint8_t)TIM5_CCR2L_RESET_VALUE;
     75              TIM5->CCR3H = (uint8_t)TIM5_CCR3H_RESET_VALUE;
     76              TIM5->CCR3L = (uint8_t)TIM5_CCR3L_RESET_VALUE;
     77              TIM5->SR1 = (uint8_t)TIM5_SR1_RESET_VALUE;
     78          }
     79          
     80          
     81          /**
     82            * @brief  Initializes the TIM5 Time Base Unit according to the specified parameters.
     83            * @param    TIM5_Prescaler specifies the Prescaler from TIM5_Prescaler_TypeDef.
     84            * @param    TIM5_Period specifies the Period value.
     85            * @retval None
     86            */
     87          void TIM5_TimeBaseInit( TIM5_Prescaler_TypeDef TIM5_Prescaler,
     88                                  uint16_t TIM5_Period)
     89          {
     90              /* Set the Prescaler value */
     91              TIM5->PSCR = (uint8_t)(TIM5_Prescaler);
     92              /* Set the Autoreload value */
     93              TIM5->ARRH = (uint8_t)(TIM5_Period >> 8) ;
     94              TIM5->ARRL = (uint8_t)(TIM5_Period);
     95          }
     96          
     97          
     98          /**
     99            * @brief  Initializes the TIM5 Channel1 according to the specified parameters.
    100            * @param   TIM5_OCMode specifies the Output Compare mode  from @ref TIM5_OCMode_TypeDef.
    101            * @param   TIM5_OutputState specifies the Output State  from @ref TIM5_OutputState_TypeDef.
    102            * @param   TIM5_Pulse specifies the Pulse width  value.
    103            * @param   TIM5_OCPolarity specifies the Output Compare Polarity  from @ref TIM5_OCPolarity_TypeDef.
    104            * @retval None
    105            */
    106          void TIM5_OC1Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    107                            TIM5_OutputState_TypeDef TIM5_OutputState,
    108                            uint16_t TIM5_Pulse,
    109                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
    110          {
    111              /* Check the parameters */
    112              assert_param(IS_TIM5_OC_MODE_OK(TIM5_OCMode));
    113              assert_param(IS_TIM5_OUTPUT_STATE_OK(TIM5_OutputState));
    114              assert_param(IS_TIM5_OC_POLARITY_OK(TIM5_OCPolarity));
    115          
    116              /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , the Output Polarity */
    117              TIM5->CCER1 &= (uint8_t)(~( TIM5_CCER1_CC1E | TIM5_CCER1_CC1P));
    118              /* Set the Output State &  Set the Output Polarity  */
    119              TIM5->CCER1 |= (uint8_t)((uint8_t)(TIM5_OutputState & TIM5_CCER1_CC1E )| 
    120                                       (uint8_t)(TIM5_OCPolarity & TIM5_CCER1_CC1P));
    121          
    122              /* Reset the Output Compare Bits  & Set the Output Compare Mode */
    123              TIM5->CCMR1 = (uint8_t)((uint8_t)(TIM5->CCMR1 & (uint8_t)(~TIM5_CCMR_OCM)) | 
    124                                      (uint8_t)TIM5_OCMode);
    125          
    126              /* Set the Pulse value */
    127              TIM5->CCR1H = (uint8_t)(TIM5_Pulse >> 8);
    128              TIM5->CCR1L = (uint8_t)(TIM5_Pulse);
    129          }
    130          
    131          
    132          /**
    133            * @brief  Initializes the TIM5 Channel2 according to the specified parameters.
    134            * @param   TIM5_OCMode specifies the Output Compare mode  from @ref TIM5_OCMode_TypeDef.
    135            * @param   TIM5_OutputState specifies the Output State  from @ref TIM5_OutputState_TypeDef.
    136            * @param   TIM5_Pulse specifies the Pulse width  value.
    137            * @param   TIM5_OCPolarity specifies the Output Compare Polarity  from @ref TIM5_OCPolarity_TypeDef.
    138            * @retval None
    139            */
    140          void TIM5_OC2Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    141                            TIM5_OutputState_TypeDef TIM5_OutputState,
    142                            uint16_t TIM5_Pulse,
    143                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
    144          {
    145              /* Check the parameters */
    146              assert_param(IS_TIM5_OC_MODE_OK(TIM5_OCMode));
    147              assert_param(IS_TIM5_OUTPUT_STATE_OK(TIM5_OutputState));
    148              assert_param(IS_TIM5_OC_POLARITY_OK(TIM5_OCPolarity));
    149          
    150          
    151              /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , the Output Polarity */
    152              TIM5->CCER1 &= (uint8_t)(~( TIM5_CCER1_CC2E |  TIM5_CCER1_CC2P ));
    153              /* Set the Output State & Set the Output Polarity  */
    154              TIM5->CCER1 |= (uint8_t)((uint8_t)(TIM5_OutputState  & TIM5_CCER1_CC2E )| \
    155                                  (uint8_t)(TIM5_OCPolarity & TIM5_CCER1_CC2P));
    156          
    157          
    158              /* Reset the Output Compare Bits  & Set the Output Compare Mode */
    159              TIM5->CCMR2 = (uint8_t)((uint8_t)(TIM5->CCMR2 & (uint8_t)(~TIM5_CCMR_OCM)) |
    160                                      (uint8_t)TIM5_OCMode);
    161          
    162          
    163              /* Set the Pulse value */
    164              TIM5->CCR2H = (uint8_t)(TIM5_Pulse >> 8);
    165              TIM5->CCR2L = (uint8_t)(TIM5_Pulse);
    166          }
    167          
    168          
    169          /**
    170            * @brief  Initializes the TIM5 Channel3 according to the specified parameters.
    171            * @param   TIM5_OCMode specifies the Output Compare mode from @ref TIM5_OCMode_TypeDef.
    172            * @param   TIM5_OutputState specifies the Output State from @ref TIM5_OutputState_TypeDef.
    173            * @param   TIM5_Pulse specifies the Pulse width value.
    174            * @param   TIM5_OCPolarity specifies the Output Compare Polarity  from @ref TIM5_OCPolarity_TypeDef.
    175            * @retval None
    176            */
    177          void TIM5_OC3Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    178                            TIM5_OutputState_TypeDef TIM5_OutputState,
    179                            uint16_t TIM5_Pulse,
    180                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
    181          {
    182              /* Check the parameters */
    183              assert_param(IS_TIM5_OC_MODE_OK(TIM5_OCMode));
    184              assert_param(IS_TIM5_OUTPUT_STATE_OK(TIM5_OutputState));
    185              assert_param(IS_TIM5_OC_POLARITY_OK(TIM5_OCPolarity));
    186              /* Disable the Channel 1: Reset the CCE Bit, Set the Output State, the Output Polarity */
    187              TIM5->CCER2 &= (uint8_t)(~( TIM5_CCER2_CC3E  | TIM5_CCER2_CC3P));
    188              /* Set the Output State & Set the Output Polarity  */
    189              TIM5->CCER2 |= (uint8_t)((uint8_t)(TIM5_OutputState  & TIM5_CCER2_CC3E   )|
    190                                       (uint8_t)(TIM5_OCPolarity   & TIM5_CCER2_CC3P   ));
    191          
    192              /* Reset the Output Compare Bits  & Set the Output Compare Mode */
    193              TIM5->CCMR3 = (uint8_t)((uint8_t)(TIM5->CCMR3 & (uint8_t)(~TIM5_CCMR_OCM)) | (uint8_t)TIM5_OCMode);
    194          
    195              /* Set the Pulse value */
    196              TIM5->CCR3H = (uint8_t)(TIM5_Pulse >> 8);
    197              TIM5->CCR3L = (uint8_t)(TIM5_Pulse);
    198          
    199          }
    200          
    201          
    202          /**
    203            * @brief  Initializes the TIM5 peripheral according to the specified parameters.
    204            * @param    TIM5_Channel specifies the Input Capture Channel from @ref TIM5_Channel_TypeDef.
    205            * @param   TIM5_ICPolarity specifies the Input Capture Polarity from @ref TIM5_ICPolarity_TypeDef.
    206            * @param   TIM5_ICSelection specifies theInput Capture Selection from @ref TIM5_ICSelection_TypeDef.
    207            * @param   TIM5_ICPrescaler specifies the Input Capture Prescaler from @ref TIM5_ICPSC_TypeDef.
    208            * @param   TIM5_ICFilter specifies the Input Capture Filter value (value can be an integer from 0x00 to 0x0F).
    209            * @retval None
    210            */
    211          void TIM5_ICInit(TIM5_Channel_TypeDef TIM5_Channel,
    212                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    213                           TIM5_ICSelection_TypeDef TIM5_ICSelection,
    214                           TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
    215                           uint8_t TIM5_ICFilter)
    216          {
    217              /* Check the parameters */
    218              assert_param(IS_TIM5_CHANNEL_OK(TIM5_Channel));
    219              assert_param(IS_TIM5_IC_POLARITY_OK(TIM5_ICPolarity));
    220              assert_param(IS_TIM5_IC_SELECTION_OK(TIM5_ICSelection));
    221              assert_param(IS_TIM5_IC_PRESCALER_OK(TIM5_ICPrescaler));
    222              assert_param(IS_TIM5_IC_FILTER_OK(TIM5_ICFilter));
    223          
    224              if (TIM5_Channel == TIM5_CHANNEL_1)
    225              {
    226                  /* TI1 Configuration */
    227                  TI1_Config((uint8_t)TIM5_ICPolarity,
    228                             (uint8_t)TIM5_ICSelection,
    229                             (uint8_t)TIM5_ICFilter);
    230          
    231                  /* Set the Input Capture Prescaler value */
    232                  TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
    233              }
    234              else if (TIM5_Channel == TIM5_CHANNEL_2)
    235              {
    236                  /* TI2 Configuration */
    237                  TI2_Config((uint8_t)TIM5_ICPolarity,
    238                             (uint8_t)TIM5_ICSelection,
    239                             (uint8_t)TIM5_ICFilter);
    240          
    241                  /* Set the Input Capture Prescaler value */
    242                  TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
    243              }
    244              else
    245              {
    246                  /* TI3 Configuration */
    247                  TI3_Config((uint8_t)TIM5_ICPolarity,
    248                             (uint8_t)TIM5_ICSelection,
    249                             (uint8_t)TIM5_ICFilter);
    250          
    251                  /* Set the Input Capture Prescaler value */
    252                  TIM5_SetIC3Prescaler(TIM5_ICPrescaler);
    253              }
    254          }
    255          
    256          
    257          /**
    258            * @brief  Configures the TIM5 peripheral in PWM Input Mode according to the specified parameters.
    259              * @param    TIM5_Channel specifies the Input Capture Channel from @ref TIM5_Channel_TypeDef.
    260            * @param   TIM5_ICPolarity specifies the Input Capture Polarity from @ref TIM5_ICPolarity_TypeDef.
    261            * @param   TIM5_ICSelection specifies theInput Capture Selection from @ref TIM5_ICSelection_TypeDef.
    262            * @param   TIM5_ICPrescaler specifies the Input Capture Prescaler from @ref TIM5_ICPSC_TypeDef.
    263            * @param   TIM5_ICFilter specifies the Input Capture Filter value (value can be an integer from 0x00 to 0x0F).
    264            * @retval None
    265            */
    266          void TIM5_PWMIConfig(TIM5_Channel_TypeDef TIM5_Channel,
    267                               TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    268                               TIM5_ICSelection_TypeDef TIM5_ICSelection,
    269                               TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
    270                               uint8_t TIM5_ICFilter)
    271          {
    272              uint8_t icpolarity = (uint8_t)TIM5_ICPOLARITY_RISING;
    273              uint8_t icselection = (uint8_t)TIM5_ICSELECTION_DIRECTTI;
    274          
    275              /* Check the parameters */
    276              assert_param(IS_TIM5_PWMI_CHANNEL_OK(TIM5_Channel));
    277              assert_param(IS_TIM5_IC_POLARITY_OK(TIM5_ICPolarity));
    278              assert_param(IS_TIM5_IC_SELECTION_OK(TIM5_ICSelection));
    279              assert_param(IS_TIM5_IC_PRESCALER_OK(TIM5_ICPrescaler));
    280          
    281              /* Select the Opposite Input Polarity */
    282              if (TIM5_ICPolarity != TIM5_ICPOLARITY_FALLING)
    283              {
    284                  icpolarity = (uint8_t)TIM5_ICPOLARITY_FALLING;
    285              }
    286              else
    287              {
    288                  icpolarity = (uint8_t)TIM5_ICPOLARITY_RISING;
    289              }
    290          
    291              /* Select the Opposite Input */
    292              if (TIM5_ICSelection == TIM5_ICSELECTION_DIRECTTI)
    293              {
    294                  icselection = (uint8_t)TIM5_ICSELECTION_INDIRECTTI;
    295              }
    296              else
    297              {
    298                  icselection = (uint8_t)TIM5_ICSELECTION_DIRECTTI;
    299              }
    300          
    301              if (TIM5_Channel == TIM5_CHANNEL_1)
    302              {
    303                  /* TI1 Configuration */
    304                  TI1_Config((uint8_t)TIM5_ICPolarity, (uint8_t)TIM5_ICSelection,
    305                             (uint8_t)TIM5_ICFilter);
    306          
    307                  /* Set the Input Capture Prescaler value */
    308                  TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
    309          
    310                  /* TI2 Configuration */
    311                  TI2_Config((uint8_t)icpolarity, (uint8_t)icselection, (uint8_t)TIM5_ICFilter);
    312          
    313                  /* Set the Input Capture Prescaler value */
    314                  TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
    315              }
    316              else
    317              {
    318                  /* TI2 Configuration */
    319                  TI2_Config((uint8_t)TIM5_ICPolarity, (uint8_t)TIM5_ICSelection,
    320                             (uint8_t)TIM5_ICFilter);
    321          
    322                  /* Set the Input Capture Prescaler value */
    323                  TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
    324          
    325                  /* TI1 Configuration */
    326                  TI1_Config((uint8_t)icpolarity, (uint8_t)icselection, (uint8_t)TIM5_ICFilter);
    327          
    328                  /* Set the Input Capture Prescaler value */
    329                  TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
    330              }
    331          }
    332          
    333          
    334          /**
    335            * @brief  Enables or disables the TIM5 peripheral.
    336            * @param   NewState new state of the TIM5 peripheral.This parameter can
    337            * be ENABLE or DISABLE.
    338            * @retval None
    339            */
    340          void TIM5_Cmd(FunctionalState NewState)
    341          {
    342              /* Check the parameters */
    343              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    344          
    345              /* set or Reset the CEN Bit */
    346              if (NewState != DISABLE)
    347              {
    348                  TIM5->CR1 |= TIM5_CR1_CEN ;
    349              }
    350              else
    351              {
    352                  TIM5->CR1 &= (uint8_t)(~TIM5_CR1_CEN) ;
    353              }
    354          }
    355          
    356          
    357          /**
    358            * @brief  Enables or disables the specified TIM5 interrupts.
    359            * @param   NewState new state of the TIM5 peripheral.
    360            * This parameter can be: ENABLE or DISABLE.
    361            * @param   TIM5_IT specifies the TIM5 interrupts sources to be enabled or disabled.
    362            * This parameter can be any combination of the following values:
    363            *                       - TIM5_IT_UPDATE: TIM5 update Interrupt source
    364            *                       - TIM5_IT_CC1: TIM5 Capture Compare 1 Interrupt source
    365            *                       - TIM5_IT_CC2: TIM5 Capture Compare 2 Interrupt source
    366            *                       - TIM5_IT_CC3: TIM5 Capture Compare 3 Interrupt source
    367            * @param   NewState new state of the TIM5 peripheral.
    368            * @retval None
    369            */
    370          void TIM5_ITConfig(TIM5_IT_TypeDef TIM5_IT, FunctionalState NewState)
    371          {
    372              /* Check the parameters */
    373              assert_param(IS_TIM5_IT_OK(TIM5_IT));
    374              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    375          
    376              if (NewState != DISABLE)
    377              {
    378                  /* Enable the Interrupt sources */
    379                  TIM5->IER |= (uint8_t)TIM5_IT;
    380              }
    381              else
    382              {
    383                  /* Disable the Interrupt sources */
    384                  TIM5->IER &= (uint8_t)(~TIM5_IT);
    385              }
    386          }
    387          
    388          
    389          /**
    390            * @brief  Enables or Disables the TIM5 Update event.
    391            * @param   NewState new state of the TIM5 peripheral Preload register.This parameter can
    392            * be ENABLE or DISABLE.
    393            * @retval None
    394            */
    395          void TIM5_UpdateDisableConfig(FunctionalState NewState)
    396          {
    397              /* Check the parameters */
    398              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    399          
    400              /* Set or Reset the UDIS Bit */
    401              if (NewState != DISABLE)
    402              {
    403                  TIM5->CR1 |= TIM5_CR1_UDIS ;
    404              }
    405              else
    406              {
    407                  TIM5->CR1 &= (uint8_t)(~TIM5_CR1_UDIS) ;
    408              }
    409          }
    410          
    411          /**
    412            * @brief  Selects the TIM5 Update Request Interrupt source.
    413            * @param   TIM5_UpdateSource specifies the Update source.
    414            * This parameter can be one of the following values
    415            *                       - TIM5_UPDATESOURCE_REGULAR
    416            *                       - TIM5_UPDATESOURCE_GLOBAL
    417            * @retval None
    418            */
    419          void TIM5_UpdateRequestConfig(TIM5_UpdateSource_TypeDef TIM5_UpdateSource)
    420          {
    421              /* Check the parameters */
    422              assert_param(IS_TIM5_UPDATE_SOURCE_OK(TIM5_UpdateSource));
    423          
    424              /* Set or Reset the URS Bit */
    425              if (TIM5_UpdateSource != TIM5_UPDATESOURCE_GLOBAL)
    426              {
    427                  TIM5->CR1 |= TIM5_CR1_URS ;
    428              }
    429              else
    430              {
    431                  TIM5->CR1 &= (uint8_t)(~TIM5_CR1_URS) ;
    432              }
    433          }
    434          
    435          
    436          /**
    437            * @brief  Selects the TIM5’s One Pulse Mode.
    438            * @param   TIM5_OPMode specifies the OPM Mode to be used.
    439            * This parameter can be one of the following values
    440            *                    - TIM5_OPMODE_SINGLE
    441            *                    - TIM5_OPMODE_REPETITIVE
    442            * @retval None
    443            */
    444          void TIM5_SelectOnePulseMode(TIM5_OPMode_TypeDef TIM5_OPMode)
    445          {
    446              /* Check the parameters */
    447              assert_param(IS_TIM5_OPM_MODE_OK(TIM5_OPMode));
    448          
    449              /* Set or Reset the OPM Bit */
    450              if (TIM5_OPMode != TIM5_OPMODE_REPETITIVE)
    451              {
    452                  TIM5->CR1 |= TIM5_CR1_OPM ;
    453              }
    454              else
    455              {
    456                  TIM5->CR1 &= (uint8_t)(~TIM5_CR1_OPM) ;
    457              }
    458          
    459          }
    460          
    461          
    462          /**
    463            * @brief  Configures the TIM5 Prescaler.
    464            * @param   Prescaler specifies the Prescaler Register value
    465            * This parameter can be one of the following values
    466            *                       -  TIM5_PRESCALER_1
    467            *                       -  TIM5_PRESCALER_2
    468            *                       -  TIM5_PRESCALER_4
    469            *                       -  TIM5_PRESCALER_8
    470            *                       -  TIM5_PRESCALER_16
    471            *                       -  TIM5_PRESCALER_32
    472            *                       -  TIM5_PRESCALER_64
    473            *                       -  TIM5_PRESCALER_128
    474            *                       -  TIM5_PRESCALER_256
    475            *                       -  TIM5_PRESCALER_512
    476            *                       -  TIM5_PRESCALER_1024
    477            *                       -  TIM5_PRESCALER_2048
    478            *                       -  TIM5_PRESCALER_4096
    479            *                       -  TIM5_PRESCALER_8192
    480            *                       -  TIM5_PRESCALER_16384
    481            *                       -  TIM5_PRESCALER_32768
    482            * @param   TIM5_PSCReloadMode specifies the TIM5 Prescaler Reload mode.
    483            * This parameter can be one of the following values
    484            *                       - TIM5_PSCRELOADMODE_IMMEDIATE: The Prescaler is loaded
    485            *                         immediatly.
    486            *                       - TIM5_PSCRELOADMODE_UPDATE: The Prescaler is loaded at
    487            *                         the update event.
    488            * @retval None
    489            */
    490          void TIM5_PrescalerConfig(TIM5_Prescaler_TypeDef Prescaler,
    491                                    TIM5_PSCReloadMode_TypeDef TIM5_PSCReloadMode)
    492          {
    493              /* Check the parameters */
    494              assert_param(IS_TIM5_PRESCALER_RELOAD_OK(TIM5_PSCReloadMode));
    495              assert_param(IS_TIM5_PRESCALER_OK(Prescaler));
    496          
    497              /* Set the Prescaler value */
    498              TIM5->PSCR = (uint8_t)Prescaler;
    499          
    500              /* Set or reset the UG Bit */
    501              TIM5->EGR = (uint8_t)TIM5_PSCReloadMode ;
    502          }
    503          
    504          /**
    505            * @brief  Forces the TIM5 Channel1 output waveform to active or inactive level.
    506            * @param   TIM5_ForcedAction specifies the forced Action to be set to the output waveform.
    507            * This parameter can be one of the following values:
    508            *                       - TIM5_FORCEDACTION_ACTIVE: Force active level on OC1REF
    509            *                       - TIM5_FORCEDACTION_INACTIVE: Force inactive level on
    510            *                         OC1REF.
    511            * @retval None
    512            */
    513          void TIM5_ForcedOC1Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    514          {
    515              /* Check the parameters */
    516              assert_param(IS_TIM5_FORCED_ACTION_OK(TIM5_ForcedAction));
    517          
    518              /* Reset the OCM Bits */ /* Configure The Forced output Mode */
    519              TIM5->CCMR1  =  (uint8_t)((uint8_t)(TIM5->CCMR1 & (uint8_t)(~TIM5_CCMR_OCM))
    520                                        | (uint8_t)TIM5_ForcedAction);
    521          }
    522          
    523          /**
    524            * @brief  Forces the TIM5 Channel2 output waveform to active or inactive level.
    525            * @param   TIM5_ForcedAction specifies the forced Action to be set to the output waveform.
    526            * This parameter can be one of the following values:
    527            *                       - TIM5_FORCEDACTION_ACTIVE: Force active level on OC2REF
    528            *                       - TIM5_FORCEDACTION_INACTIVE: Force inactive level on
    529            *                         OC2REF.
    530            * @retval None
    531            */
    532          void TIM5_ForcedOC2Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    533          {
    534              /* Check the parameters */
    535              assert_param(IS_TIM5_FORCED_ACTION_OK(TIM5_ForcedAction));
    536          
    537              /* Reset the OCM Bits */ /* Configure The Forced output Mode */
    538              TIM5->CCMR2  =  (uint8_t)((uint8_t)(TIM5->CCMR2 & (uint8_t)(~TIM5_CCMR_OCM))
    539                                        | (uint8_t)TIM5_ForcedAction);
    540          }
    541          
    542          /**
    543            * @brief  Forces the TIM5 Channel3 output waveform to active or inactive level.
    544            * @param   TIM5_ForcedAction specifies the forced Action to be set to the output waveform.
    545            * This parameter can be one of the following values:
    546            *                       - TIM5_FORCEDACTION_ACTIVE: Force active level on OC3REF
    547            *                       - TIM5_FORCEDACTION_INACTIVE: Force inactive level on
    548            *                         OC3REF.
    549            * @retval None
    550            */
    551          void TIM5_ForcedOC3Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    552          {
    553              /* Check the parameters */
    554              assert_param(IS_TIM5_FORCED_ACTION_OK(TIM5_ForcedAction));
    555          
    556              /* Reset the OCM Bits */ /* Configure The Forced output Mode */
    557              TIM5->CCMR3  =  (uint8_t)((uint8_t)(TIM5->CCMR3 & (uint8_t)(~TIM5_CCMR_OCM))  
    558                                        | (uint8_t)TIM5_ForcedAction);
    559          }
    560          
    561          
    562          /**
    563            * @brief  Enables or disables TIM5 peripheral Preload register on ARR.
    564            * @param   NewState new state of the TIM5 peripheral Preload register.
    565            * This parameter can be ENABLE or DISABLE.
    566            * @retval None
    567            */
    568          void TIM5_ARRPreloadConfig(FunctionalState NewState)
    569          {
    570              /* Check the parameters */
    571              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    572          
    573              /* Set or Reset the ARPE Bit */
    574              if (NewState != DISABLE)
    575              {
    576                  TIM5->CR1 |= TIM5_CR1_ARPE ;
    577              }
    578              else
    579              {
    580                  TIM5->CR1 &= (uint8_t)(~TIM5_CR1_ARPE) ;
    581              }
    582          }
    583          
    584          
    585          /**
    586            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR1.
    587            * @param   NewState new state of the Capture Compare Preload register.
    588            * This parameter can be ENABLE or DISABLE.
    589            * @retval None
    590            */
    591          void TIM5_OC1PreloadConfig(FunctionalState NewState)
    592          {
    593              /* Check the parameters */
    594              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    595          
    596              /* Set or Reset the OC1PE Bit */
    597              if (NewState != DISABLE)
    598              {
    599                  TIM5->CCMR1 |= TIM5_CCMR_OCxPE ;
    600              }
    601              else
    602              {
    603                  TIM5->CCMR1 &= (uint8_t)(~TIM5_CCMR_OCxPE) ;
    604              }
    605          }
    606          
    607          
    608          /**
    609            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR2.
    610            * @param   NewState new state of the Capture Compare Preload register.
    611            * This parameter can be ENABLE or DISABLE.
    612            * @retval None
    613            */
    614          void TIM5_OC2PreloadConfig(FunctionalState NewState)
    615          {
    616              /* Check the parameters */
    617              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    618          
    619              /* Set or Reset the OC2PE Bit */
    620              if (NewState != DISABLE)
    621              {
    622                  TIM5->CCMR2 |= TIM5_CCMR_OCxPE ;
    623              }
    624              else
    625              {
    626                  TIM5->CCMR2 &= (uint8_t)(~TIM5_CCMR_OCxPE) ;
    627              }
    628          }
    629          
    630          
    631          /**
    632            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR3.
    633            * @param   NewState new state of the Capture Compare Preload register.
    634            * This parameter can be ENABLE or DISABLE.
    635            * @retval None
    636            */
    637          void TIM5_OC3PreloadConfig(FunctionalState NewState)
    638          {
    639              /* Check the parameters */
    640              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    641          
    642              /* Set or Reset the OC3PE Bit */
    643              if (NewState != DISABLE)
    644              {
    645                  TIM5->CCMR3 |= TIM5_CCMR_OCxPE ;
    646              }
    647              else
    648              {
    649                  TIM5->CCMR3 &= (uint8_t)(~TIM5_CCMR_OCxPE) ;
    650              }
    651          }
    652          
    653          
    654          /**
    655            * @brief  Configures the TIM5 event to be generated by software.
    656            * @param   TIM5_EventSource specifies the event source.
    657            * This parameter can be one of the following values:
    658            *                       - TIM5_EVENTSOURCE_UPDATE: TIM5 update Event source
    659            *                       - TIM5_EVENTSOURCE_CC1: TIM5 Capture Compare 1 Event source
    660            *                       - TIM5_EVENTSOURCE_CC2: TIM5 Capture Compare 2 Event source
    661            *                       - TIM5_EVENTSOURCE_CC3: TIM5 Capture Compare 3 Event source
    662            * @retval None
    663            */
    664          void TIM5_GenerateEvent(TIM5_EventSource_TypeDef TIM5_EventSource)
    665          {
    666              /* Check the parameters */
    667              assert_param(IS_TIM5_EVENT_SOURCE_OK(TIM5_EventSource));
    668          
    669              /* Set the event sources */
    670              TIM5->EGR = (uint8_t)TIM5_EventSource;
    671          }
    672          
    673          
    674          /**
    675            * @brief  Configures the TIM5 Channel 1 polarity.
    676            * @param   TIM5_OCPolarity specifies the OC1 Polarity.
    677            * This parameter can be one of the following values:
    678            *                       - TIM5_OCPOLARITY_LOW: Output Compare active low
    679            *                       - TIM5_OCPOLARITY_HIGH: Output Compare active high
    680            * @retval None
    681            */
    682          void TIM5_OC1PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
    683          {
    684              /* Check the parameters */
    685              assert_param(IS_TIM5_OC_POLARITY_OK(TIM5_OCPolarity));
    686          
    687              /* Set or Reset the CC1P Bit */
    688              if (TIM5_OCPolarity != TIM5_OCPOLARITY_HIGH)
    689              {
    690                  TIM5->CCER1 |= TIM5_CCER1_CC1P ;
    691              }
    692              else
    693              {
    694                  TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC1P) ;
    695              }
    696          }
    697          
    698          
    699          /**
    700            * @brief  Configures the TIM5 Channel 2 polarity.
    701            * @param   TIM5_OCPolarity specifies the OC2 Polarity.
    702            * This parameter can be one of the following values:
    703            *                       - TIM5_OCPOLARITY_LOW: Output Compare active low
    704            *                       - TIM5_OCPOLARITY_HIGH: Output Compare active high
    705            * @retval None
    706            */
    707          void TIM5_OC2PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
    708          {
    709              /* Check the parameters */
    710              assert_param(IS_TIM5_OC_POLARITY_OK(TIM5_OCPolarity));
    711          
    712              /* Set or Reset the CC2P Bit */
    713              if (TIM5_OCPolarity != TIM5_OCPOLARITY_HIGH)
    714              {
    715                  TIM5->CCER1 |= TIM5_CCER1_CC2P ;
    716              }
    717              else
    718              {
    719                  TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC2P) ;
    720              }
    721          }
    722          
    723          
    724          /**
    725            * @brief  Configures the TIM5 Channel 3 polarity.
    726            * @param   TIM5_OCPolarity specifies the OC3 Polarity.
    727            * This parameter can be one of the following values:
    728            *                       - TIM5_OCPOLARITY_LOW: Output Compare active low
    729            *                       - TIM5_OCPOLARITY_HIGH: Output Compare active high
    730            * @retval None
    731            */
    732          void TIM5_OC3PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
    733          {
    734              /* Check the parameters */
    735              assert_param(IS_TIM5_OC_POLARITY_OK(TIM5_OCPolarity));
    736          
    737              /* Set or Reset the CC3P Bit */
    738              if (TIM5_OCPolarity != TIM5_OCPOLARITY_HIGH)
    739              {
    740                  TIM5->CCER2 |= TIM5_CCER2_CC3P ;
    741              }
    742              else
    743              {
    744                  TIM5->CCER2 &= (uint8_t)(~TIM5_CCER2_CC3P) ;
    745              }
    746          }
    747          
    748          
    749          /**
    750            * @brief  Enables or disables the TIM5 Capture Compare Channel x.
    751            * @param   TIM5_Channel specifies the TIM5 Channel.
    752            * This parameter can be one of the following values:
    753            *                       - TIM5_Channel1: TIM5 Channel1
    754            *                       - TIM5_Channel2: TIM5 Channel2
    755            *                       - TIM5_Channel3: TIM5 Channel3
    756            * @param   NewState specifies the TIM5 Channel CCxE bit new state.
    757            * This parameter can be: ENABLE or DISABLE.
    758            * @retval None
    759            */
    760          void TIM5_CCxCmd(TIM5_Channel_TypeDef TIM5_Channel, FunctionalState NewState)
    761          {
    762              /* Check the parameters */
    763              assert_param(IS_TIM5_CHANNEL_OK(TIM5_Channel));
    764              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    765          
    766              if (TIM5_Channel == TIM5_CHANNEL_1)
    767              {
    768                  /* Set or Reset the CC1E Bit */
    769                  if (NewState != DISABLE)
    770                  {
    771                      TIM5->CCER1 |= TIM5_CCER1_CC1E ;
    772                  }
    773                  else
    774                  {
    775                      TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC1E) ;
    776                  }
    777          
    778              }
    779              else if (TIM5_Channel == TIM5_CHANNEL_2)
    780              {
    781                  /* Set or Reset the CC2E Bit */
    782                  if (NewState != DISABLE)
    783                  {
    784                      TIM5->CCER1 |= TIM5_CCER1_CC2E;
    785                  }
    786                  else
    787                  {
    788                      TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC2E) ;
    789                  }
    790              }
    791              else
    792              {
    793                  /* Set or Reset the CC3E Bit */
    794                  if (NewState != DISABLE)
    795                  {
    796                      TIM5->CCER2 |= TIM5_CCER2_CC3E;
    797                  }
    798                  else
    799                  {
    800                      TIM5->CCER2 &= (uint8_t)(~TIM5_CCER2_CC3E) ;
    801                  }
    802              }
    803          }
    804          
    805          /**
    806            * @brief  Selects the TIM5 Output Compare Mode. This function disables the
    807            * selected channel before changing the Output Compare Mode. User has to
    808            * enable this channel using TIM5_CCxCmd and TIM5_CCxNCmd functions.
    809            * @param   TIM5_Channel specifies the TIM5 Channel.
    810            * This parameter can be one of the following values:
    811            *                       - TIM5_Channel1: TIM5 Channel1
    812            *                       - TIM5_Channel2: TIM5 Channel2
    813            *                       - TIM5_Channel3: TIM5 Channel3
    814            * @param   TIM5_OCMode specifies the TIM5 Output Compare Mode.
    815            * This paramter can be one of the following values:
    816            *                       - TIM5_OCMODE_TIMING
    817            *                       - TIM5_OCMODE_ACTIVE
    818            *                       - TIM5_OCMODE_TOGGLE
    819            *                       - TIM5_OCMODE_PWM1
    820            *                       - TIM5_OCMODE_PWM2
    821            *                       - TIM5_FORCEDACTION_ACTIVE
    822            *                       - TIM5_FORCEDACTION_INACTIVE
    823            * @retval None
    824            */
    825          void TIM5_SelectOCxM(TIM5_Channel_TypeDef TIM5_Channel, TIM5_OCMode_TypeDef TIM5_OCMode)
    826          {
    827              /* Check the parameters */
    828              assert_param(IS_TIM5_CHANNEL_OK(TIM5_Channel));
    829              assert_param(IS_TIM5_OCM_OK(TIM5_OCMode));
    830          
    831              if (TIM5_Channel == TIM5_CHANNEL_1)
    832              {
    833                  /* Disable the Channel 1: Reset the CCE Bit */
    834                  TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC1E);
    835          
    836                  /* Reset the Output Compare Bits  Set the Output Compare Mode */
    837                  TIM5->CCMR1 = (uint8_t)((uint8_t)(TIM5->CCMR1 & (uint8_t)(~TIM5_CCMR_OCM)) 
    838                                          | (uint8_t)TIM5_OCMode);
    839              }
    840              else if (TIM5_Channel == TIM5_CHANNEL_2)
    841              {
    842                  /* Disable the Channel 2: Reset the CCE Bit */
    843                  TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC2E);
    844          
    845                  /* Reset the Output Compare Bits ** Set the Output Compare Mode */
    846                  TIM5->CCMR2 = (uint8_t)((uint8_t)(TIM5->CCMR2 & (uint8_t)(~TIM5_CCMR_OCM))
    847                                          | (uint8_t)TIM5_OCMode);
    848              }
    849              else
    850              {
    851                  /* Disable the Channel 3: Reset the CCE Bit */
    852                  TIM5->CCER2 &= (uint8_t)(~TIM5_CCER2_CC3E);
    853          
    854                  /* Reset the Output Compare Bits ** Set the Output Compare Mode */
    855                  TIM5->CCMR3 = (uint8_t)((uint8_t)(TIM5->CCMR3 & (uint8_t)(~TIM5_CCMR_OCM))
    856                                          | (uint8_t)TIM5_OCMode);
    857              }
    858          }
    859          
    860          
    861          /**
    862            * @brief  Sets the TIM5 Counter Register value.
    863            * @param   Counter specifies the Counter register new value.
    864            * This parameter is between 0x0000 and 0xFFFF.
    865            * @retval None
    866            */
    867          void TIM5_SetCounter(uint16_t Counter)
    868          {
    869              /* Set the Counter Register value */
    870              TIM5->CNTRH = (uint8_t)(Counter >> 8);
    871              TIM5->CNTRL = (uint8_t)(Counter);
    872          
    873          }
    874          
    875          
    876          /**
    877            * @brief  Sets the TIM5 Autoreload Register value.
    878            * @param   Autoreload specifies the Autoreload register new value.
    879            * This parameter is between 0x0000 and 0xFFFF.
    880            * @retval None
    881            */
    882          void TIM5_SetAutoreload(uint16_t Autoreload)
    883          {
    884          
    885              /* Set the Autoreload Register value */
    886              TIM5->ARRH = (uint8_t)(Autoreload >> 8);
    887              TIM5->ARRL = (uint8_t)(Autoreload);
    888          
    889          }
    890          
    891          
    892          /**
    893            * @brief  Sets the TIM5 Capture Compare1 Register value.
    894            * @param   Compare1 specifies the Capture Compare1 register new value.
    895            * This parameter is between 0x0000 and 0xFFFF.
    896            * @retval None
    897            */
    898          void TIM5_SetCompare1(uint16_t Compare1)
    899          {
    900              /* Set the Capture Compare1 Register value */
    901              TIM5->CCR1H = (uint8_t)(Compare1 >> 8);
    902              TIM5->CCR1L = (uint8_t)(Compare1);
    903          
    904          }
    905          
    906          
    907          /**
    908            * @brief  Sets the TIM5 Capture Compare2 Register value.
    909            * @param   Compare2 specifies the Capture Compare2 register new value.
    910            * This parameter is between 0x0000 and 0xFFFF.
    911            * @retval None
    912            */
    913          void TIM5_SetCompare2(uint16_t Compare2)
    914          {
    915              /* Set the Capture Compare2 Register value */
    916              TIM5->CCR2H = (uint8_t)(Compare2 >> 8);
    917              TIM5->CCR2L = (uint8_t)(Compare2);
    918          
    919          }
    920          
    921          
    922          /**
    923            * @brief  Sets the TIM5 Capture Compare3 Register value.
    924            * @param   Compare3 specifies the Capture Compare3 register new value.
    925            * This parameter is between 0x0000 and 0xFFFF.
    926            * @retval None
    927            */
    928          void TIM5_SetCompare3(uint16_t Compare3)
    929          {
    930              /* Set the Capture Compare3 Register value */
    931              TIM5->CCR3H = (uint8_t)(Compare3 >> 8);
    932              TIM5->CCR3L = (uint8_t)(Compare3);
    933          
    934          }
    935          
    936          
    937          /**
    938            * @brief  Sets the TIM5 Input Capture 1 prescaler.
    939            * @param   TIM5_IC1Prescaler specifies the Input Capture prescaler new value
    940            * This parameter can be one of the following values:
    941            *                       - TIM5_ICPSC_DIV1: no prescaler
    942            *                       - TIM5_ICPSC_DIV2: capture is done once every 2 events
    943            *                       - TIM5_ICPSC_DIV4: capture is done once every 4 events
    944            *                       - TIM5_ICPSC_DIV8: capture is done once every 8 events
    945            * @retval None
    946            */
    947          void TIM5_SetIC1Prescaler(TIM5_ICPSC_TypeDef TIM5_IC1Prescaler)
    948          {
    949              /* Check the parameters */
    950              assert_param(IS_TIM5_IC_PRESCALER_OK(TIM5_IC1Prescaler));
    951          
    952              /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
    953              TIM5->CCMR1 = (uint8_t)((uint8_t)(TIM5->CCMR1 & (uint8_t)(~TIM5_CCMR_ICxPSC))|
    954                                      (uint8_t)TIM5_IC1Prescaler);
    955          }
    956          
    957          /**
    958            * @brief  Sets the TIM5 Input Capture 2 prescaler.
    959            * @param   TIM5_IC2Prescaler specifies the Input Capture prescaler new value
    960            * This parameter can be one of the following values:
    961            *                       - TIM5_ICPSC_DIV1: no prescaler
    962            *                       - TIM5_ICPSC_DIV2: capture is done once every 2 events
    963            *                       - TIM5_ICPSC_DIV4: capture is done once every 4 events
    964            *                       - TIM5_ICPSC_DIV8: capture is done once every 8 events
    965            * @retval None
    966            */
    967          void TIM5_SetIC2Prescaler(TIM5_ICPSC_TypeDef TIM5_IC2Prescaler)
    968          {
    969              /* Check the parameters */
    970              assert_param(IS_TIM5_IC_PRESCALER_OK(TIM5_IC2Prescaler));
    971          
    972              /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
    973              TIM5->CCMR2 = (uint8_t)((uint8_t)(TIM5->CCMR2 & (uint8_t)(~TIM5_CCMR_ICxPSC))
    974                                      | (uint8_t)TIM5_IC2Prescaler);
    975          }
    976          
    977          /**
    978            * @brief  Sets the TIM5 Input Capture 3 prescaler.
    979            * @param   TIM5_IC3Prescaler specifies the Input Capture prescaler new value
    980            * This parameter can be one of the following values:
    981            *                       - TIM5_ICPSC_DIV1: no prescaler
    982            *                       - TIM5_ICPSC_DIV2: capture is done once every 2 events
    983            *                       - TIM5_ICPSC_DIV4: capture is done once every 4 events
    984            *                       - TIM5_ICPSC_DIV8: capture is done once every 8 events
    985            * @retval None
    986            */
    987          void TIM5_SetIC3Prescaler(TIM5_ICPSC_TypeDef TIM5_IC3Prescaler)
    988          {
    989          
    990              /* Check the parameters */
    991              assert_param(IS_TIM5_IC_PRESCALER_OK(TIM5_IC3Prescaler));
    992              /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
    993              TIM5->CCMR3 = (uint8_t)((uint8_t)(TIM5->CCMR3 & (uint8_t)(~TIM5_CCMR_ICxPSC)) |
    994                                      (uint8_t)TIM5_IC3Prescaler);
    995          }
    996          
    997          /**
    998            * @brief  Gets the TIM5 Input Capture 1 value.
    999            * @param  None
   1000            * @retval Capture Compare 1 Register value.
   1001            */
   1002          uint16_t TIM5_GetCapture1(void)
   1003          {
   1004             uint16_t temp = 0; 
   1005            
   1006             temp = ((uint16_t)TIM5->CCR1H << 8); 
   1007            
   1008             /* Get the Capture 1 Register value */
   1009              return (uint16_t)(temp | (uint16_t)(TIM5->CCR1L));
   1010          }
   1011          
   1012          /**
   1013            * @brief  Gets the TIM5 Input Capture 2 value.
   1014            * @param  None
   1015            * @retval Capture Compare 2 Register value.
   1016            */
   1017          uint16_t TIM5_GetCapture2(void)
   1018          {
   1019            uint16_t temp = 0; 
   1020            
   1021             temp = ((uint16_t)TIM5->CCR2H << 8);  
   1022            
   1023            /* Get the Capture 2 Register value */
   1024              return (uint16_t)(temp | (uint16_t)(TIM5->CCR2L));
   1025          }
   1026          
   1027          /**
   1028            * @brief  Gets the TIM5 Input Capture 3 value.
   1029            * @param  None
   1030            * @retval Capture Compare 3 Register value.
   1031            */
   1032          uint16_t TIM5_GetCapture3(void)
   1033          {
   1034             uint16_t temp = 0; 
   1035            
   1036             temp = ((uint16_t)TIM5->CCR3H << 8);
   1037             /* Get the Capture 1 Register value */
   1038              return (uint16_t)(temp | (uint16_t)(TIM5->CCR3L));
   1039          }
   1040          
   1041          /**
   1042            * @brief  Gets the TIM5 Counter value.
   1043            * @param  None
   1044            * @retval Counter Register value.
   1045            */
   1046          uint16_t TIM5_GetCounter(void)
   1047          {
   1048            uint16_t tmpcntr = 0;
   1049          
   1050            tmpcntr = ((uint16_t)TIM5->CNTRH << 8); 
   1051            /* Get the Counter Register value */
   1052              return (uint16_t)(tmpcntr | (uint16_t)(TIM5->CNTRL));
   1053          }
   1054          
   1055          
   1056          /**
   1057            * @brief  Gets the TIM5 Prescaler value.
   1058            * @param  None
   1059            * @retval Prescaler Register configuration value  @ref TIM5_Prescaler_TypeDef .
   1060            */
   1061          TIM5_Prescaler_TypeDef TIM5_GetPrescaler(void)
   1062          {
   1063              /* Get the Prescaler Register value */
   1064              return (TIM5_Prescaler_TypeDef)(TIM5->PSCR);
   1065          }
   1066          
   1067          
   1068          
   1069          /**
   1070            * @brief  Checks whether the specified TIM5 flag is set or not.
   1071            * @param   TIM5_FLAG specifies the flag to check.
   1072            * This parameter can be one of the following values:
   1073            *                       - TIM5_FLAG_UPDATE: TIM5 update Flag
   1074            *                       - TIM5_FLAG_CC1: TIM5 Capture Compare 1 Flag
   1075            *                       - TIM5_FLAG_CC2: TIM5 Capture Compare 2 Flag
   1076            *                       - TIM5_FLAG_CC3: TIM5 Capture Compare 3 Flag
   1077            *                       - TIM5_FLAG_CC1OF: TIM5 Capture Compare 1 overcapture Flag
   1078            *                       - TIM5_FLAG_CC2OF: TIM5 Capture Compare 2 overcapture Flag
   1079            *                       - TIM5_FLAG_CC3OF: TIM5 Capture Compare 3 overcapture Flag
   1080            * @retval FlagStatus The new state of TIM5_FLAG (SET or RESET).
   1081            */
   1082          FlagStatus TIM5_GetFlagStatus(TIM5_FLAG_TypeDef TIM5_FLAG)
   1083          {
   1084              FlagStatus bitstatus = RESET;
   1085              uint8_t tim5_flag_l, tim5_flag_h;
   1086          
   1087              /* Check the parameters */
   1088              assert_param(IS_TIM5_GET_FLAG_OK(TIM5_FLAG));
   1089          
   1090              tim5_flag_l= (uint8_t)(TIM5->SR1 & (uint8_t)TIM5_FLAG);
   1091              tim5_flag_h= (uint8_t)((uint16_t)TIM5_FLAG >> 8);
   1092          
   1093              if (((tim5_flag_l)|(uint8_t)(TIM5->SR2 & tim5_flag_h)) != RESET )
   1094              {
   1095                  bitstatus = SET;
   1096              }
   1097              else
   1098              {
   1099                  bitstatus = RESET;
   1100              }
   1101              return (FlagStatus)bitstatus;
   1102          }
   1103          
   1104          
   1105          /**
   1106            * @brief  Clears the TIM5’s pending flags.
   1107            * @param   TIM5_FLAG specifies the flag to clear.
   1108            * This parameter can be one of the following values:
   1109            *                       - TIM5_FLAG_UPDATE: TIM5 update Flag
   1110            *                       - TIM5_FLAG_CC1: TIM5 Capture Compare 1 Flag
   1111            *                       - TIM5_FLAG_CC2: TIM5 Capture Compare 2 Flag
   1112            *                       - TIM5_FLAG_CC3: TIM5 Capture Compare 3 Flag
   1113            *                       - TIM5_FLAG_CC1OF: TIM5 Capture Compare 1 overcapture Flag
   1114            *                       - TIM5_FLAG_CC2OF: TIM5 Capture Compare 2 overcapture Flag
   1115            *                       - TIM5_FLAG_CC3OF: TIM5 Capture Compare 3 overcapture Flag
   1116            * @retval None.
   1117            */
   1118          void TIM5_ClearFlag(TIM5_FLAG_TypeDef TIM5_FLAG)
   1119          {
   1120              /* Check the parameters */
   1121              assert_param(IS_TIM5_CLEAR_FLAG_OK(TIM5_FLAG));
   1122          
   1123              /* Clear the flags (rc_w0) clear this bit by writing 0. Writing ‘1’ has no effect*/
   1124              TIM5->SR1 = (uint8_t)(~((uint8_t)(TIM5_FLAG)));
   1125              TIM5->SR2 &= (uint8_t)(~((uint8_t)((uint16_t)TIM5_FLAG >> 8)));
   1126          }
   1127          
   1128          
   1129          /**
   1130            * @brief  Checks whether the TIM5 interrupt has occurred or not.
   1131            * @param   TIM5_IT specifies the TIM5 interrupt source to check.
   1132            * This parameter can be one of the following values:
   1133            *                       - TIM5_IT_UPDATE: TIM5 update Interrupt source
   1134            *                       - TIM5_IT_CC1: TIM5 Capture Compare 1 Interrupt source
   1135            *                       - TIM5_IT_CC2: TIM5 Capture Compare 2 Interrupt source
   1136            *                       - TIM5_IT_CC3: TIM5 Capture Compare 3 Interrupt source
   1137            * @retval ITStatus The new state of the TIM5_IT(SET or RESET).
   1138            */
   1139          
   1140          ITStatus TIM5_GetITStatus(TIM5_IT_TypeDef TIM5_IT)
   1141          {
   1142              ITStatus bitstatus = RESET;
   1143              uint8_t TIM5_itStatus = 0, TIM5_itEnable = 0;
   1144          
   1145              /* Check the parameters */
   1146              assert_param(IS_TIM5_GET_IT_OK(TIM5_IT));
   1147          
   1148              TIM5_itStatus = (uint8_t)(TIM5->SR1 & TIM5_IT);
   1149          
   1150              TIM5_itEnable = (uint8_t)(TIM5->IER & TIM5_IT);
   1151          
   1152              if ((TIM5_itStatus != (uint8_t)RESET ) && (TIM5_itEnable != (uint8_t)RESET ))
   1153              {
   1154                  bitstatus = SET;
   1155              }
   1156              else
   1157              {
   1158                  bitstatus = RESET;
   1159              }
   1160              return (ITStatus)(bitstatus);
   1161          }
   1162          
   1163          
   1164          /**
   1165            * @brief  Clears the TIM5's interrupt pending bits.
   1166            * @param   TIM5_IT specifies the pending bit to clear.
   1167            * This parameter can be one of the following values:
   1168            *                       - TIM5_IT_UPDATE: TIM5 update Interrupt source
   1169            *                       - TIM5_IT_CC1: TIM5 Capture Compare 1 Interrupt source
   1170            *                       - TIM5_IT_CC2: TIM5 Capture Compare 2 Interrupt source
   1171            *                       - TIM5_IT_CC3: TIM5 Capture Compare 3 Interrupt source
   1172            * @retval None.
   1173            */
   1174          void TIM5_ClearITPendingBit(TIM5_IT_TypeDef TIM5_IT)
   1175          {
   1176              /* Check the parameters */
   1177              assert_param(IS_TIM5_IT_OK(TIM5_IT));
   1178          
   1179              /* Clear the IT pending Bit */
   1180              TIM5->SR1 = (uint8_t)(~TIM5_IT);
   1181          }
   1182          
   1183          
   1184          /**
   1185            * @brief  Configure the TI1 as Input.
   1186            * @param   TIM5_ICPolarity  The Input Polarity.
   1187            * This parameter can be one of the following values:
   1188            *                       - TIM5_ICPOLARITY_FALLING
   1189            *                       - TIM5_ICPOLARITY_RISING
   1190            * @param   TIM5_ICSelection specifies the input to be used.
   1191            * This parameter can be one of the following values:
   1192            *                       - TIM5_ICSELECTION_DIRECTTI: TIM5 Input 1 is selected to
   1193            *                         be connected to IC1.
   1194            *                       - TIM5_ICSELECTION_INDIRECTTI: TIM5 Input 1 is selected to
   1195            *                         be connected to IC2.
   1196            * @param   TIM5_ICFilter Specifies the Input Capture Filter.
   1197            * This parameter must be a value between 0x00 and 0x0F.
   1198            * @retval None
   1199            */
   1200          static void TI1_Config(uint8_t TIM5_ICPolarity,
   1201                                 uint8_t TIM5_ICSelection,
   1202                                 uint8_t TIM5_ICFilter)
   1203          {
   1204              /* Disable the Channel 1: Reset the CCE Bit */
   1205              TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC1E);
   1206          
   1207              /* Select the Input and set the filter */
   1208              TIM5->CCMR1  = (uint8_t)((uint8_t)(TIM5->CCMR1 & (uint8_t)(~( TIM5_CCMR_CCxS | TIM5_CCMR_ICxF )))
   1209                                       | (uint8_t)(( (TIM5_ICSelection)) | ((uint8_t)( TIM5_ICFilter << 4))));
   1210          
   1211              /* Select the Polarity */
   1212              if (TIM5_ICPolarity != TIM5_ICPOLARITY_RISING)
   1213              {
   1214                  TIM5->CCER1 |= TIM5_CCER1_CC1P ;
   1215              }
   1216              else
   1217              {
   1218                  TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC1P) ;
   1219              }
   1220              /* Set the CCE Bit */
   1221              TIM5->CCER1 |=  TIM5_CCER1_CC1E;
   1222          }
   1223          
   1224          
   1225          /**
   1226            * @brief  Configure the TI2 as Input.
   1227            * @param   TIM5_ICPolarity  The Input Polarity.
   1228            * This parameter can be one of the following values:
   1229            *                       - TIM5_ICPOLARITY_FALLING
   1230            *                       - TIM5_ICPOLARITY_RISING
   1231            * @param   TIM5_ICSelection specifies the input to be used.
   1232            * This parameter can be one of the following values:
   1233            *                       - TIM5_ICSELECTION_DIRECTTI: TIM5 Input 2 is selected to
   1234            *                         be connected to IC2.
   1235            *                       - TIM5_ICSELECTION_INDIRECTTI: TIM5 Input 2 is selected to
   1236            *                         be connected to IC1.
   1237            * @param   TIM5_ICFilter Specifies the Input Capture Filter.
   1238            * This parameter must be a value between 0x00 and 0x0F.
   1239            * @retval None
   1240            */
   1241          static void TI2_Config(uint8_t TIM5_ICPolarity,
   1242                                 uint8_t TIM5_ICSelection,
   1243                                 uint8_t TIM5_ICFilter)
   1244          {
   1245              /* Disable the Channel 2: Reset the CCE Bit */
   1246              TIM5->CCER1 &=  (uint8_t)(~TIM5_CCER1_CC2E);
   1247          
   1248              /* Select the Input and set the filter */
   1249              TIM5->CCMR2  = (uint8_t)((uint8_t)(TIM5->CCMR2 & (uint8_t)(~( TIM5_CCMR_CCxS | TIM5_CCMR_ICxF)))
   1250                                       | (uint8_t)(( (TIM5_ICSelection)) | ((uint8_t)( TIM5_ICFilter << 4))));
   1251          
   1252          
   1253              /* Select the Polarity */
   1254              if (TIM5_ICPolarity != TIM5_ICPOLARITY_RISING)
   1255              {
   1256                  TIM5->CCER1 |= TIM5_CCER1_CC2P ;
   1257              }
   1258              else
   1259              {
   1260                  TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC2P) ;
   1261              }
   1262          
   1263              /* Set the CCE Bit */
   1264              TIM5->CCER1 |=  TIM5_CCER1_CC2E;
   1265          
   1266          }
   1267          
   1268          /**
   1269            * @brief  Configure the TI3 as Input.
   1270            * @param   TIM5_ICPolarity  The Input Polarity.
   1271            * This parameter can be one of the following values:
   1272            *                       - TIM5_ICPOLARITY_FALLING
   1273            *                       - TIM5_ICPOLARITY_RISING
   1274            * @param   TIM5_ICSelection specifies the input to be used.
   1275            * This parameter can be one of the following values:
   1276            *                       - TIM5_ICSELECTION_DIRECTTI: TIM5 Input 3 is selected to
   1277            *                         be connected to IC3.
   1278            * @param   TIM5_ICFilter Specifies the Input Capture Filter.
   1279            * This parameter must be a value between 0x00 and 0x0F.
   1280            * @retval None
   1281            */
   1282          static void TI3_Config(uint8_t TIM5_ICPolarity, uint8_t TIM5_ICSelection,
   1283                                 uint8_t TIM5_ICFilter)
   1284          {
   1285              /* Disable the Channel 3: Reset the CCE Bit */
   1286              TIM5->CCER2 &=  (uint8_t)(~TIM5_CCER2_CC3E);
   1287          
   1288              /* Select the Input and set the filter */
   1289              TIM5->CCMR3 = (uint8_t)((uint8_t)(TIM5->CCMR3 & (uint8_t)(~( TIM5_CCMR_CCxS | TIM5_CCMR_ICxF))) 
   1290                                      | (uint8_t)(( (TIM5_ICSelection)) | ((uint8_t)( TIM5_ICFilter << 4))));
   1291          
   1292          
   1293              /* Select the Polarity */
   1294              if (TIM5_ICPolarity != TIM5_ICPOLARITY_RISING)
   1295              {
   1296                  TIM5->CCER2 |= TIM5_CCER2_CC3P ;
   1297              }
   1298              else
   1299              {
   1300                  TIM5->CCER2 &= (uint8_t)(~TIM5_CCER2_CC3P) ;
   1301              }
   1302              /* Set the CCE Bit */
   1303              TIM5->CCER2 |=  TIM5_CCER2_CC3E;
   1304          }
   1305          /**
   1306            * @brief  Enables the TIM5 internal Clock.
   1307            * @par Parameters:
   1308          	* None
   1309            * @retval None
   1310            */
   1311          void TIM5_InternalClockConfig(void)
   1312          {
   1313              /* Disable slave mode to clock the prescaler directly with the internal clock */
   1314              TIM5->SMCR &=  (uint8_t)(~TIM5_SMCR_SMS);
   1315          }
   1316          
   1317          /**
   1318            * @brief  Selects the TIM5 Trigger Output Mode.
   1319            * @param   TIM5_TRGOSource : Specifies the Trigger Output source.
   1320            * This parameter can be one of the @ref TIM5_TRGOSource_TypeDef enumeration.
   1321            * @retval None
   1322            */
   1323          void TIM5_SelectOutputTrigger(TIM5_TRGOSource_TypeDef TIM5_TRGOSource)
   1324          {
   1325              uint8_t tmpcr2 = 0;
   1326          
   1327              /* Check the parameters */
   1328              assert_param(IS_TIM5_TRGO_SOURCE_OK(TIM5_TRGOSource));
   1329          
   1330              tmpcr2 = TIM5->CR2;
   1331          
   1332              /* Reset the MMS Bits */
   1333              tmpcr2 &= (uint8_t)(~TIM5_CR2_MMS);
   1334          
   1335              /* Select the TRGO source */
   1336              tmpcr2 |=  (uint8_t)TIM5_TRGOSource;
   1337          
   1338              TIM5->CR2 = tmpcr2;
   1339          }
   1340          /**
   1341            * @brief  Selects the TIM5 Slave Mode.
   1342            * @param   TIM5_SlaveMode : Specifies the TIM5 Slave Mode.
   1343            * This parameter can be one of the @ref TIM5_SlaveMode_TypeDef enumeration.
   1344            * @retval None
   1345            */
   1346          void TIM5_SelectSlaveMode(TIM5_SlaveMode_TypeDef TIM5_SlaveMode)
   1347          {
   1348              uint8_t tmpsmcr = 0;
   1349          
   1350              /* Check the parameters */
   1351              assert_param(IS_TIM5_SLAVE_MODE_OK(TIM5_SlaveMode));
   1352          
   1353              tmpsmcr = TIM5->SMCR;
   1354          
   1355              /* Reset the SMS Bits */
   1356              tmpsmcr &= (uint8_t)(~TIM5_SMCR_SMS);
   1357          
   1358              /* Select the Slave Mode */
   1359              tmpsmcr |= (uint8_t)TIM5_SlaveMode;
   1360          
   1361              TIM5->SMCR = tmpsmcr;
   1362          }
   1363          /**
   1364            * @brief  Selects the TIM5 Input Trigger source.
   1365            * @param   TIM5_InputTriggerSource : Specifies Input Trigger source.
   1366            * This parameter can be one of the @ref TIM5_TS_TypeDef enumeration.
   1367            * @retval None
   1368            */
   1369          void TIM5_SelectInputTrigger(TIM5_TS_TypeDef TIM5_InputTriggerSource)
   1370          {
   1371              uint8_t tmpsmcr = 0;
   1372          
   1373              /* Check the parameters */
   1374              assert_param(IS_TIM5_TRIGGER_SELECTION_OK(TIM5_InputTriggerSource));
   1375          
   1376              tmpsmcr = TIM5->SMCR;
   1377          
   1378              /* Select the Tgigger Source */
   1379              tmpsmcr &= (uint8_t)(~TIM5_SMCR_TS);
   1380              tmpsmcr |= (uint8_t)TIM5_InputTriggerSource;
   1381          
   1382              TIM5->SMCR = (uint8_t)tmpsmcr;
   1383          }
   1384          /**
   1385            * @brief  Configures the TIM5 Encoder Interface.
   1386            * @param   TIM5_EncoderMode : Specifies the TIM5 Encoder Mode.
   1387            * This parameter can be one of the @ref TIM5_EncoderMode_TypeDef enumeration.
   1388            * @param   TIM5_IC1Polarity : Specifies the IC1 Polarity.
   1389            * This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
   1390            * @param   TIM5_IC2Polarity : Specifies the IC2 Polarity.
   1391            * This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
   1392            * @retval None
   1393            */
   1394          void TIM5_EncoderInterfaceConfig(TIM5_EncoderMode_TypeDef TIM5_EncoderMode,
   1395                                           TIM5_ICPolarity_TypeDef TIM5_IC1Polarity,
   1396                                           TIM5_ICPolarity_TypeDef TIM5_IC2Polarity)
   1397          {
   1398              uint8_t tmpsmcr = 0;
   1399              uint8_t tmpccmr1 = 0;
   1400              uint8_t tmpccmr2 = 0;
   1401          
   1402              /* Check the parameters */
   1403              assert_param(IS_TIM5_ENCODER_MODE_OK(TIM5_EncoderMode));
   1404              assert_param(IS_TIM5_IC_POLARITY_OK(TIM5_IC1Polarity));
   1405              assert_param(IS_TIM5_IC_POLARITY_OK(TIM5_IC2Polarity));
   1406          
   1407              tmpsmcr = TIM5->SMCR;
   1408              tmpccmr1 = TIM5->CCMR1;
   1409              tmpccmr2 = TIM5->CCMR2;
   1410          
   1411              /* Set the encoder Mode */
   1412              tmpsmcr &= (uint8_t)(TIM5_SMCR_MSM | TIM5_SMCR_TS)  ;
   1413              tmpsmcr |= (uint8_t)TIM5_EncoderMode;
   1414          
   1415              /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1416              tmpccmr1 &= (uint8_t)(~TIM5_CCMR_CCxS);
   1417              tmpccmr2 &= (uint8_t)(~TIM5_CCMR_CCxS);
   1418              tmpccmr1 |= TIM5_CCMR_TIxDirect_Set;
   1419              tmpccmr2 |= TIM5_CCMR_TIxDirect_Set;
   1420          
   1421              /* Set the TI1 and the TI2 Polarities */
   1422              if (TIM5_IC1Polarity == TIM5_ICPOLARITY_FALLING)
   1423              {
   1424                  TIM5->CCER1 |= TIM5_CCER1_CC1P ;
   1425              }
   1426              else
   1427              {
   1428                  TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC1P) ;
   1429              }
   1430          
   1431              if (TIM5_IC2Polarity == TIM5_ICPOLARITY_FALLING)
   1432              {
   1433                  TIM5->CCER1 |= TIM5_CCER1_CC2P ;
   1434              }
   1435              else
   1436              {
   1437                  TIM5->CCER1 &= (uint8_t)(~TIM5_CCER1_CC2P) ;
   1438              }
   1439          
   1440              TIM5->SMCR = tmpsmcr;
   1441              TIM5->CCMR1 = tmpccmr1;
   1442              TIM5->CCMR2 = tmpccmr2;
   1443          }
   1444          
   1445          /**
   1446            * @}
   1447            */
   1448          
   1449          /**
   1450            * @}
   1451            */
   1452          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

Errors: 68
Warnings: none
